# DO NOT EDIT - Generated scaffold
# TODO: Implement your business logic

from __future__ import annotations

import argparse
import asyncio
import logging
import sys
from pathlib import Path

from actr import ActrSystem, WorkloadBase, Context

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format="[%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# æ·»åŠ  generated ç›®å½•åˆ° Python è·¯å¾„
generated_dir = Path(__file__).parent / "generated"
if str(generated_dir) not in sys.path:
    sys.path.insert(0, str(generated_dir))

# åŠ¨æ€å¯¼å…¥ç”Ÿæˆçš„æ¨¡å—
from generated.local import {{PROTO_MODULE}}_pb2 as pb2
from generated import {{ACTOR_MODULE}} as actor

{{#if HAS_SERVICES}}
{{#each SERVICES}}

class {{../SERVICE_NAME}}Handler(actor.{{this.name}}Handler):
    """
    {{../SERVICE_NAME}} ä¸šåŠ¡é€»è¾‘å®ç°
    TODO: åœ¨æ­¤ç±»ä¸­å®ç°å…·ä½“çš„ RPC æ–¹æ³•
    """

    def __init__(self) -> None:
        logger.info("{{../SERVICE_NAME}}Handler å®ä¾‹å·²åˆå§‹åŒ–")

    {{#each this.methods}}

    async def {{this.snake_name}}(
        self, req: pb2.{{this.input_type}}, ctx: Context
    ) -> pb2.{{this.output_type}}:
        """
        TODO: å®ç° {{this.name}} RPC æ–¹æ³•

        Args:
            req: {{this.input_type}} è¯·æ±‚å¯¹è±¡
            ctx: Actor ä¸Šä¸‹æ–‡ï¼Œç”¨äºæœåŠ¡å‘ç°æˆ–è°ƒç”¨å…¶ä»– Service

        Returns:
            {{this.output_type}} å“åº”å¯¹è±¡
        """
        logger.info("ğŸ“ æ¥æ”¶åˆ° RPC è°ƒç”¨: {{this.name}}")

        # ç¤ºä¾‹å®ç°é€»è¾‘:
        # return pb2.{{this.output_type}}(
        #     field1="value",
        #     field2=123,
        # )

        raise NotImplementedError("æ–¹æ³• {{this.name}} å°šæœªå®ç°")

    {{/each}}
{{/each}}

class {{WORKLOAD_NAME}}(WorkloadBase):
    def __init__(self, handler: {{SERVICE_NAME}}Handler):
        self.handler = handler
        super().__init__(actor.{{DISPATCHER_NAME}}())

    async def on_start(self, ctx: Context) -> None:
        logger.info("ğŸš€ å·¥ä½œè´Ÿè½½ {{WORKLOAD_NAME}} æ­£åœ¨å¯åŠ¨...")

    async def on_stop(self, ctx: Context) -> None:
        logger.info("ğŸ›‘ å·¥ä½œè´Ÿè½½ {{WORKLOAD_NAME}} æ­£åœ¨åœæ­¢...")

{{else}}

# å®¢æˆ·ç«¯å·¥ä½œè´Ÿè½½ (æœªå®šä¹‰æœ¬åœ°æœåŠ¡)
class {{WORKLOAD_NAME}}(WorkloadBase):
    def __init__(self):
        # ä½¿ç”¨ç”Ÿæˆçš„ EmptyDispatcherï¼ˆæ­¤å®¢æˆ·ç«¯æ²¡æœ‰éœ€è¦å¤„ç†çš„å…¥ç«™ RPCï¼‰
        super().__init__(actor.EmptyDispatcher())

    async def on_start(self, ctx: Context) -> None:
        logger.info("ğŸš€ å®¢æˆ·ç«¯å·¥ä½œè´Ÿè½½ {{WORKLOAD_NAME}} å¯åŠ¨")
        # TODO: åœ¨è¿™é‡Œæ·»åŠ ä½ çš„å®¢æˆ·ç«¯é€»è¾‘
        # ä¾‹å¦‚: è°ƒç”¨è¿œç¨‹æœåŠ¡
        # dest = Dest.actor(ActrType.parse("acme+RemoteService"), "instance-id")
        # response = await ctx.call_raw(dest, "MethodName", request_pb.SerializeToString())

    async def on_stop(self, ctx: Context) -> None:
        logger.info("ğŸ›‘ å®¢æˆ·ç«¯å·¥ä½œè´Ÿè½½ {{WORKLOAD_NAME}} åœæ­¢")

{{/if}}

async def main() -> int:
    ap = argparse.ArgumentParser(description="{{SERVICE_NAME}} Runner")
    ap.add_argument("--actr-toml", required=True, help="ACTR é…ç½®æ–‡ä»¶è·¯å¾„")
    args = ap.parse_args()

    logger.info("ğŸ”§ æ­£åœ¨åˆå§‹åŒ– {{SERVICE_NAME}} ç³»ç»Ÿ...")
    system = await ActrSystem.from_toml(args.actr_toml)

    {{#if HAS_SERVICES}}
    workload = {{WORKLOAD_NAME}}({{SERVICE_NAME}}Handler())
    {{else}}
    workload = {{WORKLOAD_NAME}}()
    {{/if}}

    node = system.attach(workload)
    ref = await node.start()

    logger.info("âœ… {{SERVICE_NAME}} å¯åŠ¨æˆåŠŸ! Actor ID: %s", ref.actor_id())

    # ç­‰å¾…ä¸­æ–­ä¿¡å·å¹¶å…³é—­
    await ref.wait_for_ctrl_c_and_shutdown()
    logger.info("ğŸ‘‹ {{SERVICE_NAME}} å·²å…³é—­")

    return 0


if __name__ == "__main__":
    try:
        sys_exit_code = asyncio.run(main())
        raise SystemExit(sys_exit_code)
    except KeyboardInterrupt:
        pass