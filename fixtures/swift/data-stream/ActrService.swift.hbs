import Actr
import Foundation
import OSLog
import SwiftProtobuf
import SwiftUI

// ActrService is Implemented: This file contains a complete implementation.
// This file will not be overwritten by actr gen.

@MainActor
final class ActrService: ObservableObject {
    @Published var connectionStatus: ConnectionStatus = .disconnected
    @Published var errorMessage: String?

    var actrSystem: ActrSystem?
    var actrNode: ActrNode?
    var actr: Actr?
    private var workload: {{SERVICE_NAME}}Workload<{{SERVICE_NAME}}HandlerImpl>?
    private let logger = Logger(
        subsystem: Bundle.main.bundleIdentifier ?? "io.actr.App",
        category: "ActrService"
    )

    /// Initialize the service and its underlying actors
    func initialize() async throws {
        connectionStatus = .initializing
        errorMessage = nil
        logger.info("Initializing ActrService...")

        do {
            let bundle = Bundle.main
            guard let configPath = bundle.path(forResource: "Actr", ofType: "toml") else {
                throw ActrError.StateError(msg: "Actr.toml not found in bundle")
            }

            let result = try await Task.detached(priority: .userInitiated) { () throws
                -> (ActrSystem, ActrNode, Actr, {{SERVICE_NAME}}Workload<{{SERVICE_NAME}}HandlerImpl>) in
                let system = try await ActrSystem.from(tomlConfig: configPath)
                let handler = {{SERVICE_NAME}}HandlerImpl()
                let workload = {{SERVICE_NAME}}Workload(handler: handler)
                let node = try system.spawn(workload: workload)
                let actr = try await node.start()
                return (system, node, actr, workload)
            }.value

            let (system, node, actr, workload) = result
            actrSystem = system
            actrNode = node
            self.actr = actr
            self.workload = workload

            connectionStatus = .connected
            logger.info("ActrService initialized successfully")
        } catch let actrError as ActrError {
            errorMessage = "Actr Error: \(actrError.localizedDescription)"
            connectionStatus = .error
            logger.error("Failed to initialize: \(actrError.localizedDescription)")
            throw actrError
        } catch {
            errorMessage = "Initialization Error: \(error.localizedDescription)"
            connectionStatus = .error
            logger.error("Failed to initialize: \(error.localizedDescription)")
            throw error
        }
    }

    /// Shutdown the service and cleanup resources
    func shutdown() async {
        logger.info("Shutting down ActrService...")

        if let actr {
            await actr.stop()
        }

        actr = nil
        actrNode = nil
        actrSystem = nil
        workload = nil

        connectionStatus = .disconnected
        errorMessage = nil
    }
}

extension ActrService {
    enum ConnectionStatus {
        case disconnected
        case initializing
        case connected
        case error

        var description: String {
            switch self {
            case .disconnected: return "Disconnected"
            case .initializing: return "Initializing..."
            case .connected: return "Connected"
            case .error: return "Error"
            }
        }
    }

    /// Send a file via RPC request
    /// - Parameter fileURL: The URL of the file to send
    /// - Returns: SendFileResponse containing the result of the file transfer
    func sendFile(fileURL: URL) async throws -> {{PROJECT_NAME_PASCAL}}_SendFileResponse {
        guard connectionStatus == .connected else {
            throw ActrError.StateError(msg: "Not connected to server")
        }

        guard let actr = actr else {
            throw ActrError.StateError(msg: "Actor reference not available")
        }

        do {
            // Create request with file path
            var request = {{PROJECT_NAME_PASCAL}}_SendFileRequest()
            request.filePath = fileURL.path

            logger.info("Sending file at path: \(fileURL.path)")

            // Call RPC
            let response = try await actr.call(request)

            logger.info("File transfer completed: success=\(response.success)")

            return response
        } catch let actrError as ActrError {
            logger.error("File send error: \(actrError.localizedDescription)")
            throw actrError
        } catch {
            logger.error("File send error: \(error.localizedDescription)")
            throw error
        }
    }
}

/// Implementation of {{SERVICE_NAME}}Handler
public actor {{SERVICE_NAME}}HandlerImpl: {{SERVICE_NAME}}Handler {
    public init() {}

    /// RPC method: StartStream
    public func startStream(
        req: {{PROJECT_NAME_PASCAL}}_StartStreamRequest,
        ctx: ContextBridge
    ) async throws -> {{PROJECT_NAME_PASCAL}}_StartStreamResponse {
        logger.info("üì° Received StartStream request: client_id=\(req.clientID), stream_id=\(req.streamID), message_count=\(req.messageCount)")
        
        // TODO: Implement StartStream logic
        // This method is typically used to initiate a stream session
        var response = {{PROJECT_NAME_PASCAL}}_StartStreamResponse()
        response.accepted = true
        response.message = "Stream started"
        return response
    }

    /// RPC method: PrepareClientStream
    public func prepareClientStream(
        req: {{PROJECT_NAME_PASCAL}}_PrepareClientStreamRequest,
        ctx: ContextBridge
    ) async throws -> {{PROJECT_NAME_PASCAL}}_PrepareStreamResponse {
        logger.info("üì° Received PrepareClientStream request: stream_id=\(req.streamID), expected_count=\(req.expectedCount)")
        
        // TODO: Implement PrepareClientStream logic
        // This method prepares the client side for receiving a stream
        var response = {{PROJECT_NAME_PASCAL}}_PrepareStreamResponse()
        response.ready = true
        response.message = "Client stream prepared"
        return response
    }

    /// RPC method: SendFile
    public func sendFile(
        req: {{PROJECT_NAME_PASCAL}}_SendFileRequest,
        ctx: ContextBridge
    ) async throws -> {{PROJECT_NAME_PASCAL}}_SendFileResponse {
        let filePath = req.filePath
        logger.info("üì§ Starting file transfer for path: \(filePath)")

        // 1. Convert file path to URL and get filename
        let fileURL: URL
        if filePath.hasPrefix("file://") {
            guard let url = URL(string: filePath) else {
                logger.error("‚ùå Invalid file path: \(filePath)")
                var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
                response.success = false
                return response
            }
            fileURL = url
        } else {
            fileURL = URL(fileURLWithPath: filePath)
        }

        let fileName = fileURL.lastPathComponent
        logger.info("üìÑ File name: \(fileName)")

        // Ensure we have access to the file if it's a security-scoped resource
        let needsSecurityScope = fileURL.startAccessingSecurityScopedResource()
        defer {
            if needsSecurityScope {
                fileURL.stopAccessingSecurityScopedResource()
            }
        }

        let fileData: Data
        do {
            fileData = try Data(contentsOf: fileURL)
            logger.info("üìÑ File read successfully: \(fileData.count) bytes")
        } catch {
            logger.error("‚ùå Failed to read file: \(error.localizedDescription)")
            var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
            response.success = false
            return response
        }

        // 2. Split file into chunks
        let chunkSize = 1024 * 8 // 8KB chunks
        var chunks: [Data] = []
        var offset = 0
        while offset < fileData.count {
            let end = min(offset + chunkSize, fileData.count)
            chunks.append(fileData.subdata(in: offset ..< end))
            offset = end
        }

        logger.info("üì¶ File split into \(chunks.count) chunks (chunk size: \(chunkSize) bytes)")

        // 3. Discover the receiver
        let targetId: ActrId
        do {
            let targetType = try ActrType.fromStringRepr("acme+DataStreamConcurrentServer")
            logger.info("üåê Discovering receiver via signaling for type: \(targetType.manufacturer).\(targetType.name)")
            targetId = try await ctx.discover(targetType: targetType)
            logger.info("üéØ Discovered receiver: \(String(describing: targetId))")
        } catch {
            logger.error("‚ùå Failed to discover receiver: \(error.localizedDescription)")
            var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
            response.success = false
            return response
        }

        // 4. Prepare server stream
        logger.info("üì° Phase 1: Sending PrepareServerStream RPC...")
        var prepareReq = DataStreamPeer_PrepareServerStreamRequest()
        prepareReq.streamID = "file-transfer-\(UUID().uuidString)"
        prepareReq.expectedCount = UInt32(chunks.count)

        do {
            let prepareReqData = try prepareReq.serializedData()
            let prepareRespData = try await ctx.callRaw(
                target: targetId,
                routeKey: "data_stream_peer.StreamServer.PrepareStream",
                payloadType: .rpcReliable,
                payload: prepareReqData,
                timeoutMs: 30000
            )

            let prepareResp = try DataStreamPeer_PrepareStreamResponse(serializedBytes: prepareRespData)
            if !prepareResp.ready {
                logger.error("‚ùå PrepareServerStream refused: \(prepareResp.message)")
                var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
                response.success = false
                return response
            }

            logger.info("‚úÖ PrepareServerStream RPC succeeded: \(prepareResp.message)")
        } catch {
            logger.error("‚ùå PrepareServerStream failed: \(error.localizedDescription)")
            var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
            response.success = false
            return response
        }

        // 5. Send file chunks via DataStream
        logger.info("üì¶ Phase 2: Sending \(chunks.count) DataStream chunks...")
        let streamId = prepareReq.streamID

        for (i, chunk) in chunks.enumerated() {
            let dataStream = DataStream(
                streamId: streamId,
                sequence: UInt64(i),
                payload: chunk,
                metadata: [],
                timestampMs: Int64(Date().timeIntervalSince1970 * 1000)
            )

            do {
                try await ctx.sendDataStreamRaw(target: targetId, chunk: dataStream)

                if (i + 1) % 10 == 0 || i == chunks.count - 1 {
                    let progress = Int(Double(i + 1) / Double(chunks.count) * 100.0)
                    logger.info("   Sent chunk #\(i + 1)/\(chunks.count): \(chunk.count) bytes (\(progress)%)")
                }
            } catch {
                logger.error("‚ùå Failed to send chunk #\(i + 1): \(error.localizedDescription)")
                var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
                response.success = false
                return response
            }
        }

        logger.info("‚úÖ All chunks sent successfully")
        logger.info("üéâ File transfer completed successfully!")

        var response = {{PROJECT_NAME_PASCAL}}_SendFileResponse()
        response.success = true
        return response
    }
}

extension {{SERVICE_NAME}}Workload: Workload where T == {{SERVICE_NAME}}HandlerImpl {
    public func onStart(ctx _: ContextBridge) async throws {}
    public func onStop(ctx _: ContextBridge) async throws {}

    public func dispatch(ctx: ContextBridge, envelope: RpcEnvelopeBridge) async throws -> Data {
        return try await __dispatch(ctx: ctx, envelope: envelope)
    }
}

// Global logger for the handlers to use
private let logger = Logger(subsystem: "io.actr.App", category: "Handler")
