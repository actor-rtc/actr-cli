import Actr
import Foundation
import OSLog
import SwiftProtobuf
import SwiftUI

@MainActor
final class ActrService: ObservableObject {
    @Published var connectionStatus: ConnectionStatus = .disconnected
    @Published var errorMessage: String?

    internal var actrSystem: ActrSystem?
    internal var actrNode: ActrNode?
    internal var actr: Actr?
    private var workload: ClientWorkload?
    private let logger = Logger(
        subsystem: Bundle.main.bundleIdentifier ?? "io.actr.App",
        category: "ActrService"
    )

    /// Initialize the service and its underlying actors
    func initialize() async throws {
        connectionStatus = .initializing
        errorMessage = nil
        logger.info("Initializing ActrService...")

        do {
            let bundle = Bundle.main
            guard let configPath = bundle.path(forResource: "Actr", ofType: "toml") else {
                throw ActrError.StateError(msg: "Actr.toml not found in bundle")
            }

            let result = try await Task.detached(priority: .userInitiated) { () throws
                -> (ActrSystem, ActrNode, Actr, ClientWorkload) in
                let system = try await ActrSystem.from(tomlConfig: configPath)
                let workload = ClientWorkload()
                let node = try system.spawn(workload: workload)
                let actr = try await node.start()
                return (system, node, actr, workload)
            }.value

            let (system, node, actr, workload) = result
            actrSystem = system
            actrNode = node
            self.actr = actr
            self.workload = workload

            connectionStatus = .connected
            logger.info("ActrService initialized successfully")
        } catch let actrError as ActrError {
            errorMessage = "Actr Error: \(actrError.localizedDescription)"
            connectionStatus = .error
            logger.error("Failed to initialize: \(actrError.localizedDescription)")
            throw actrError
        } catch {
            errorMessage = "Initialization Error: \(error.localizedDescription)"
            connectionStatus = .error
            logger.error("Failed to initialize: \(error.localizedDescription)")
            throw error
        }
    }

    /// Shutdown the service and cleanup resources
    func shutdown() async {
        logger.info("Shutting down ActrService...")

        if let actr {
            await actr.stop()
        }

        actr = nil
        actrNode = nil
        actrSystem = nil
        workload = nil

        connectionStatus = .disconnected
        errorMessage = nil
    }
}

extension ActrService {
    enum ConnectionStatus {
        case disconnected
        case initializing
        case connected
        case error

        var description: String {
            switch self {
            case .disconnected: return "Disconnected"
            case .initializing: return "Initializing..."
            case .connected: return "Connected"
            case .error: return "Error"
            }
        }
    }
}

private actor ClientWorkload: Workload {
    init() {}

    func onStart(ctx _: ContextBridge) async throws {}
    func onStop(ctx _: ContextBridge) async throws {}

    func dispatch(ctx _: ContextBridge, envelope _: RpcEnvelopeBridge) async throws -> Data {
        throw ActrError.StateError(msg: "Run `actr gen` to generate ActrService implementation")
    }
}
