import Actr
import Foundation
import OSLog
import SwiftProtobuf
import SwiftUI

@MainActor
final class ActrService: ObservableObject {
    @Published var connectionStatus: ConnectionStatus = .disconnected
    @Published var errorMessage: String?

    private var actrSystem: ActrSystem?
    private var actrNode: ActrNode?
    private var actr: Actr?
    private var workload: ForwardingWorkload?
    private let logger = Logger(
        subsystem: Bundle.main.bundleIdentifier ?? "io.actr.App",
        category: "ActrService"
    )
    private let manufacturer: String = "{{manufacturer}}"

    /// Initialize the service and its underlying actors
    func initialize() async throws {
        connectionStatus = .initializing
        errorMessage = nil
        logger.info("Initializing ActrService...")

        do {
            let bundle = Bundle.main
            guard let configPath = bundle.path(forResource: "actr-config", ofType: "toml") else {
                throw ActrError.StateError(msg: "actr-config.toml not found in bundle")
            }

            let manufacturer = self.manufacturer
            let result = try await Task.detached(priority: .userInitiated) { () throws
                -> (ActrSystem, ActrNode, Actr, ForwardingWorkload) in
                let system = try await ActrSystem.from(tomlConfig: configPath)
                let workload = ForwardingWorkload(manufacturer: manufacturer)
                let node = try system.spawn(workload: workload)
                let actr = try await node.start()
                return (system, node, actr, workload)
            }.value

            let (system, node, actr, workload) = result
            actrSystem = system
            actrNode = node
            self.actr = actr
            self.workload = workload

            connectionStatus = .connected
            logger.info("ActrService initialized successfully")
        } catch let actrError as ActrError {
            errorMessage = "Actr Error: \(actrError.localizedDescription)"
            connectionStatus = .error
            logger.error("Failed to initialize: \(actrError.localizedDescription)")
            throw actrError
        } catch {
            errorMessage = "Initialization Error: \(error.localizedDescription)"
            connectionStatus = .error
            logger.error("Failed to initialize: \(error.localizedDescription)")
            throw error
        }
    }

{{#if has_echo_service}}
    /// Send an echo RPC request
    func sendEcho(_ message: String) async throws -> String {
        guard connectionStatus == .connected else {
            let error = ActrError.StateError(msg: "Not connected to server")
            logger.error("Failed to send echo: \(error.localizedDescription)")
            throw error
        }

        guard let actr = actr else {
            let error = ActrError.StateError(msg: "Actor reference not available")
            logger.error("Failed to send echo: \(error.localizedDescription)")
            throw error
        }

        do {
            logger.info("Sending echo message")

            var request = Echo_EchoRequest()
            request.message = message

            let response: Echo_EchoResponse = try await actr.call(
                route: "echo.EchoService.Echo",
                message: request
            )

            logger.info("Received response: \(response.reply)")
            return response.reply
        } catch let actrError as ActrError {
            errorMessage = "RPC Error: \(actrError.localizedDescription)"
            logger.error("Failed to send echo: \(actrError.localizedDescription)")
            throw actrError
        } catch {
            errorMessage = "RPC Error: \(error.localizedDescription)"
            logger.error("Failed to send echo: \(error.localizedDescription)")
            throw error
        }
    }
{{else}}
    // TODO: Add RPC wrappers for: {{services_hint}}
{{/if}}

    /// Shutdown the service and cleanup resources
    func shutdown() async {
        logger.info("Shutting down ActrService...")

        if let actr {
            await actr.stop()
        }

        actr = nil
        actrNode = nil
        actrSystem = nil
        workload = nil

        connectionStatus = .disconnected
        errorMessage = nil
    }
}

extension ActrService {
    enum ConnectionStatus {
        case disconnected
        case initializing
        case connected
        case error

        var description: String {
            switch self {
            case .disconnected: return "Disconnected"
            case .initializing: return "Initializing..."
            case .connected: return "Connected"
            case .error: return "Error"
            }
        }
    }
}

private actor ForwardingWorkload: Workload {
    private let manufacturer: String

    init(manufacturer: String) {
        self.manufacturer = manufacturer
    }

    func onStart(ctx _: ContextBridge) async throws {}
    func onStop(ctx _: ContextBridge) async throws {}

    func dispatch(ctx: ContextBridge, envelope: RpcEnvelopeBridge) async throws -> Data {
        let parts = envelope.routeKey.split(separator: ".")
        guard parts.count >= 2 else {
            throw ActrError.WorkloadError(msg: "Invalid route key: \(envelope.routeKey)")
        }
        let serviceName = String(parts[1])
        let targetType = ActrType(manufacturer: manufacturer, name: serviceName)

        let targetId = try await ctx.discover(targetType: targetType)
        return try await ctx.callRaw(
            target: targetId,
            routeKey: envelope.routeKey,
            payloadType: .rpcReliable,
            payload: envelope.payload,
            timeoutMs: 30000
        )
    }
}
