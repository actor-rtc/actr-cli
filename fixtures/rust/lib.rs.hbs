//! {{PROJECT_NAME}} - Actor-RTC service implementation

use actr_core::prelude::*;
use async_trait::async_trait;
use std::sync::Arc;
use tracing::info;

// Include generated proto code
pub mod echo {
    tonic::include_proto!("echo");
}

// Include generated actor code
include!(concat!(env!("OUT_DIR"), "/echo_service_actor.rs"));

use echo::{EchoRequest, EchoResponse};

/// Main actor implementation
#[derive(Default)]
pub struct {{PROJECT_NAME_PASCAL}}Actor {
    echo_count: std::sync::atomic::AtomicU64,
}

#[async_trait]
impl IEchoService for {{PROJECT_NAME_PASCAL}}Actor {
    async fn echo(
        &self, 
        request: EchoRequest,
        _context: Arc<Context>
    ) -> Result<EchoResponse, tonic::Status> {
        let count = self.echo_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed) + 1;
        
        info!("Received echo request #{}: {}", count, request.message);
        
        Ok(EchoResponse { 
            message: format!("Echo #{}: {}", count, request.message) 
        })
    }
}

#[async_trait]
impl ILifecycle for {{PROJECT_NAME_PASCAL}}Actor {
    async fn on_start(&self, _ctx: Arc<Context>) {
        info!("{{PROJECT_NAME_PASCAL}}Actor started successfully");
    }

    async fn on_stop(&self, _ctx: Arc<Context>) {
        info!("{{PROJECT_NAME_PASCAL}}Actor shutting down");
    }

    async fn on_actor_discovered(&self, _ctx: Arc<Context>, _actor_id: &ActorId) -> bool {
        // Accept connections from any actor
        true
    }
}

